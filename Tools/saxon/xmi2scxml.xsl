<?xml version="1.0"?>
<!--
 
-->
<xsl:stylesheet version="2.0" xmlns="http://www.w3.org/2005/07/scxml" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xmi="http://schema.omg.org/spec/XMI/2.1" xmlns:uml="http://www.eclipse.org/uml2/3.0.0/UML" xmlns:scxml="http://www.w3.org/2005/07/scxml">
  <xsl:output method="xml" indent="yes" encoding="UTF-8"/>
  <xsl:variable name="currentState" select="'aze'"/>
  <xsl:template match="uml:Package">
    <xsl:comment>
      License.
    </xsl:comment>
    <xsl:text>&#xA;</xsl:text>
    <xsl:comment>
      This file was generated by a stylesheet from Me
    </xsl:comment>
    <xsl:text>&#xA;</xsl:text>
    <scxmlfiles xmlns="">
      <xsl:apply-templates select="packagedElement"/>
    </scxmlfiles>
    <xsl:text>&#xA;</xsl:text>
  </xsl:template>
  <!--
	packagedElement (select only StateMachine elements)
	-->
  <xsl:template match="packagedElement[@xmi:type='uml:StateMachine']">
    <xsl:variable name="type" select="@xmi:type"/>
    <xsl:variable name="name" select="@name"/>
    <xsl:variable name="filename" select="concat($name,'.scxml')"/>
    <file xmlns="" uml2name="{$name}" scxmlfile="{$filename}"/>
    <xsl:result-document href="{$filename}" method="xml">
      <xsl:text>&#xA;</xsl:text>
      <xsl:comment>
        License.
      </xsl:comment>
      <xsl:text>&#xA;</xsl:text>
      <xsl:comment>
        This file was generated by a stylesheet from Me...
      </xsl:comment>
      <xsl:text>&#xA;</xsl:text>
      <xsl:choose>
        <!--
				If more than one region child then add a parallel element
				-->
        <xsl:when test="count(child::region) &gt; 1">
          <scxml version="1.0" initial="__root">
            <parallel id="__root">
              <xsl:apply-templates select="region">
                <xsl:with-param name="orth" select="true()"/>
              </xsl:apply-templates>
            </parallel>
          </scxml>
          <xsl:text>&#xA;</xsl:text>
        </xsl:when>
        <xsl:otherwise>
          <!--<scxml version="1.0" initial="{region/subvertex[@xmi:type='uml:Pseudostate'][empty(@kind)]/@xmi:id}">-->
          <scxml version="1.0" initial="{region/subvertex[@xmi:type='uml:Pseudostate'][empty(@kind)]/@name}">
            <xsl:apply-templates select="region">
              <xsl:with-param name="orth" select="false()"/>
            </xsl:apply-templates>
          </scxml>
          <xsl:text>&#xA;</xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:result-document>
  </xsl:template>
  <!-- 
	Region
	-->
  <xsl:template match="region">
    <xsl:param name="orth"/>
    <xsl:choose>
      <xsl:when test="$orth">
        <state id="{concat('__region',position())}" initial="{subvertex[@xmi:type='uml:Pseudostate'][empty(@kind)]/@name}">
          <xsl:apply-templates select="subvertex"/>
        </state>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="subvertex"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <!--
	subvertex (-> state)
	-->
  <xsl:template match="subvertex">
    <xsl:variable name="type" select="@xmi:type"/>
    <xsl:variable name="xmiid" select="@xmi:id"/>
    <xsl:variable name="name" select="@name"/>
    <xsl:variable name="id" select="if (empty($name)) then $xmiid else $name"/>
    <xsl:choose>
      <xsl:when test="$type='uml:Pseudostate'">
        <xsl:choose>
          <xsl:when test="@kind='deepHistory'">
            <history type="deep" id="{$id}">
              <xsl:apply-templates select="../transition[@source=$xmiid]"/>
            </history>
          </xsl:when>
          <xsl:when test="@kind='shallowHistory'">
            <history type="shallow" id="{$id}">
              <xsl:apply-templates select="../transition[@source=$xmiid]"/>
            </history>
          </xsl:when>
          <xsl:otherwise>
            <state id="{$id}">
              <xsl:apply-templates select="../transition[@source=$xmiid]"/>
            </state>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:when test="$type='uml:State'">
        <xsl:choose>
          <!--
					If more than one region child then add a parallel element
					-->
          <xsl:when test="count(child::region) &gt; 1">
            <parallel id="{$name}">
              <xsl:apply-templates select="../transition[@source=$xmiid]"/>
              <xsl:apply-templates select="region">
                <xsl:with-param name="orth" select="true()"/>
              </xsl:apply-templates>
            </parallel>
          </xsl:when>
          <!--
					If we have a region child then find initial state
					-->
          <xsl:when test="count(child::region) &gt; 0">
            <state id="{$id}"  initial="{region/subvertex[@xmi:type='uml:Pseudostate'][empty(@kind)]/@name}">
              <!--
							Add entry and exit log messages
							-->
              <onentry>
                <log label="'decadix'" level="'INFO'" expr="' -&gt; Entering {$id}'" />
              </onentry>
              <onexit>
                <log label="'decadix'" level="'INFO'" expr="' &lt;- Exiting {$id}'" />
              </onexit>
              <xsl:apply-templates select="../transition[@source=$xmiid]"/>
              <xsl:apply-templates select="region"/>
            </state>
          </xsl:when>
          <xsl:otherwise>
            <state id="{$id}">
              <!--
							Add entry and exit log messages
							-->
              <onentry>
                <log label="'decadix'" level="'INFO'" expr="' -&gt; Entering {$id}'" />
              </onentry>
              <onexit>
                <log label="'decadix'" level="'INFO'" expr="' &lt;- Exiting {$id}'" />
              </onexit>
              <xsl:apply-templates select="../transition[@source=$xmiid]"/>
              <xsl:apply-templates select="region"/>
            </state>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:when test="$type='uml:FinalState'">
        <final id="{$id}"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <!--
	internal transition (enter/exit actions)
	-->
  <xsl:template match="transition[@kind='internal']">
    <xsl:variable name="target" select="@target"/>
    <xsl:variable name="tname" select="if (empty(../subvertex[@xmi:id=$target]/@name)) then ../subvertex[@xmi:id=$target]/@xmi:id else ../subvertex[@xmi:id=$target]/@name"/>
    <xsl:variable name="type" select="eAnnotations/contents/defaultValue/@value" />
    <xsl:choose>
      <xsl:when test="$type='Entry'">
        <onentry>
          <script>
            <xsl:text>&#xA;</xsl:text>
            <xsl:value-of select="ownedComment/body" />
          </script>
          <!-- look for signal -->
          <xsl:apply-templates select="eAnnotations/contents[@name='Signal']"/>
        </onentry>
      </xsl:when>
      <xsl:when test="$type='Exit'">
        <onexit>
          <script>
            <xsl:text>&#xA;</xsl:text>
            <xsl:value-of select="ownedComment/body" />
          </script>
          <!-- look for signal -->
          <xsl:apply-templates select="eAnnotations/contents[@name='Signal']"/>
        </onexit>
      </xsl:when>
      <xsl:when test="$type='Do'">
        <xsl:variable name="type" select="effect/body" />
        <invoke type ="{$type}">
          <content>
          {
          <xsl:text>&#xA;</xsl:text>
          <xsl:value-of select="ownedComment/body" />
          }
          </content>
        </invoke>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
  <!--
  transition body (script)
  -->
  <xsl:template match="ownedComment/body">
    <script>
      <xsl:text>&#xA;</xsl:text>
      <xsl:value-of select="." />
    </script>    
  </xsl:template>
  <!--
  transition signal
  -->
  <xsl:template match="contents[@name='Signal']">
    <xsl:variable name="event" select="defaultValue/@value" />
    <send event="{$event}" />
  </xsl:template>
  <!--
	transition
	-->
  <xsl:template match="transition">
    <xsl:variable name="target" select="@target"/>
    <xsl:variable name="sourceId" select="@source"/>
    <xsl:variable name="source" select="//subvertex[@xmi:id=$sourceId]/@name"/>
    <xsl:variable name="tname" select="if (empty(//subvertex[@xmi:id=$target]/@name)) then //subvertex[@xmi:id=$target]/@xmi:id else //subvertex[@xmi:id=$target]/@name"/>
    <xsl:variable name="cond" select="ownedRule/specification/@value" />
    <!-- if name ends with ')' => it's a Qt event so add 'q-signal:' prefix -->
    <xsl:variable name="name" select="if (ends-with(@name, ')')) then concat('q-signal:', @name) else @name" />
    <xsl:choose>
      <xsl:when test="empty(@name)">
        <transition target="{$tname}" cond="{$cond}"/>
      </xsl:when>
      <xsl:otherwise>
        <transition event="{$name}" target="{$tname}" cond="{$cond}">
          <log label="'decadix'" level="'INFO'" expr="' == {$source} &lt;{@name}&gt; {$tname}'" />
          <xsl:apply-templates />
        </transition>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
</xsl:stylesheet>
